# 11.23习得

## 软件工程MOOC

上午第一节课和下午一小段时间做了MOOC

## 概率

基本看完了书上内容，下一步开始做往年卷子

## AI

注册了新的claude

## 入党

和家里调和了一下，简化手续就，尽快吧，沉默成本

## 服创

联邦学习本质上是一种**分布式**机器学习技术，或机器学习**框架**。

我们把每个参与共同建模的企业称为参与方，根据多参与方之间数据分布的不同，把联邦学习分为三类：横向联邦学习、纵向联邦学习和联邦迁移学习。

### 横向联邦学习

横向联邦学习的本质是**样本的联合**，适用于参与者间业态相同但触达客户不同，即特征重叠多，用户重叠少时的场景，比如不同地区的银行间，他们的业务相似（特征相似），但用户不同（样本不同）

step1：参与方各自从服务器A下载最新模型；

step2：每个参与方利用本地数据训练模型，加密梯度上传给服务器A，服务器A聚合各用户的梯度更新模型参数；

step3：服务器A返回更新后的模型给各参与方；

step4：各参与方更新各自模型。

### 纵向联邦学习

纵向联邦学习的本质是**特征的联合**，适用于用户重叠多，特征重叠少的场景，比如同一地区的商超和银行，他们触达的用户都为该地区的居民（样本相同），但业务不同（特征不同）。

![img](https://pic4.zhimg.com/v2-3d3a6fbef04273a7729364789f0902fb_r.jpg)

纵向联邦学习的本质是交叉用户在不同业态下的特征联合，比如商超A和银行B，在传统的机器学习建模过程中，需要将两部分数据集中到一个数据中心，然后再将每个用户的特征join成一条数据用来训练模型，所以就需要双方有用户交集（基于join结果建模），并有一方存在label。学习步骤如上图所示，分为两大步：

第一步：加密样本对齐。是在系统级做这件事，因此在企业感知层面不会暴露非交叉用户。

第二步：对齐样本进行模型加密训练：

step1：由第三方C向A和B发送公钥，用来加密需要传输的数据；

step2：A和B分别计算和自己相关的特征中间结果，并加密交互，用来求得各自梯度和损失；

step3：A和B分别计算各自加密后的梯度并添加掩码发送给C，同时B计算加密后的损失发送给C；

step4：C解密梯度和损失后回传给A和B，A、B去除掩码并更新模型。

### **联邦迁移学习**

当参与者间特征和样本重叠都很少时可以考虑使用联邦迁移学习，如不同地区的银行和商超间的联合。主要适用于以深度神经网络为基模型的场景。

迁移学习，是指利用数据、任务、或模型之间的相似性，将在源领域学习过的模型，应用于 目标领域的一种学习过程。

联邦迁移学习的步骤与纵向联邦学习相似，只是中间传递结果不同（实际上每个模型的中间传递结果都不同）。这里重点讲一下联邦迁移的思想：

![img](https://pic2.zhimg.com/v2-ee8292d033fc88148a030765dd18918d_r.jpg)

## Git复习

[超详细的Git使用教程(图文)-CSDN博客](https://blog.csdn.net/qq_37883866/article/details/105349257)

### 一些概念

.git隐藏文件夹就是**版本库**，版本库中存储了很多配置信息、日志信息和文件版本信息等

包含.git文件夹的目录就是**工作目录**，主要用于存放开发的代码

.git文件夹中有很多文件，其中有一个index文件就是**暂存区**，也可以叫做stage。暂存区是一个临时保存修改文件的地方

![img](https://img-blog.csdnimg.cn/2020040619284969.png)

### Git工作目录下文件的两种状态

Git工作目录下的文件存在两种状态：
untracked 未跟踪（未被纳入版本控制）
tracked 已跟踪（被纳入版本控制）
Unmodified 未修改状态
Modified 已修改状态
Staged 已暂存状态

这些文件的状态会随着我们执行Git的命令发生变化

### 操作

**git status 查看文件状态** | **git status –s 使输出信息更加简洁**

**git add 将未跟踪的文件加入暂存区**

**git add hello.txt将新创建的文件**

**git reset 将暂存区的文件取消暂存**

**git commit 将暂存区的文件修改提交到本地仓库**

**git rm 删除文件**

——上面删除的只是工作区的文件，需要提交到本地仓库

一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。

```
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the TODO file in the current directory, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
```

**git remote查看远程仓库** ——列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字

**添加远程仓库 **——运行 git remote add < shortname> < url> 添加一个新的远程 Git 仓库，同时指定一个可以引用的简写

**从远程仓库克隆 **——如果你想获得一份已经存在了的 Git 仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。
克隆仓库的命令格式是 git clone [url]

**移除无效的远程仓库**
如果因为一些原因想要移除一个远程仓库 ，可以使用 git remote rm（注意：此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库）

**从远程仓库中抓取与拉取**
git fetch 是从远程仓库获取最新版本到本地仓库，不会自动merge

git pull 是从远程仓库获取最新版本并merge到本地仓库

如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories
当执行git中的“git pull origin master –allow-unrelated-histories”命令时，会出现“ couldn’t find remote ref –allow-unrelated-histories”的错误，
输入如下命令即可解决：
git pull --rebase origin master

**将本地分支与远程分支关联：**

git branch --set-upstream-to origin/master master

**推送到远程仓库**
当你想分享你的代码时，可以将其推送到远程仓库。 命令形式：git push [remote-name] [branch-name]

### Git 分支

几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。

- 列出所有本地分支
	**git branch**
- 列出所有远程分支
	**git branch -r**
- 列出所有本地分支和远程分支
	**git branch -a**

---

未完

后面还有分支，标签，与IDEA结合等多部分内容

----

再次强烈建议这篇博客

[超详细的Git使用教程(图文)-CSDN博客](https://blog.csdn.net/qq_37883866/article/details/105349257)

## 编译原理

### Exp4

仍然是接续上次的进程

example里面仍然是示例

可以先Example跑跑试试

似乎是在当前例子文件基础上添加和完善

尽量都跑过所有代码

## Exp2

晚上主要做Exp2

看了那两个教程，大概明白了怎么做，下一次做时候把教程完整做一遍

## 一个明显的想法

我想做自媒体：

看我B站关注的一个up主，是使用AI绘图，prompt来自诗词，但都是奇奇怪怪的图像，但是成功地从自己原来小几千的粉丝换到了稳定在几万到几十万甚至近百万的播放量，我艳羡成就，遗憾自己没能迅速挖掘自己的商业敏感，但值得欣慰的是这个人成功为我提供了验证，他的视频很是单一，虽有特色，但最后可能走得就几十万（已经可以接一些广子丰衣足食了），我想构创几个账号同时发布不同类型的AI内容，多元化挖掘

**我觉得更深处说自己是对一切提升生产效率的工具都具有明显的极端的喜欢，比如gpt之外还有梯子（之前换了一个更快的梯子），上次这种酣畅淋漓还是再搞懂自己的学习痛点，但这种搞懂知识就很难遇，可以清晰记得，之前是编译原理的几个知识点，再之前是神经网络的习得**
